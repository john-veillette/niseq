
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Welcome to niseq’s documentation! &#8212; niseq 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-niseq-s-documentation">
<h1>Welcome to niseq’s documentation!<a class="headerlink" href="#welcome-to-niseq-s-documentation" title="Permalink to this headline">¶</a></h1>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>
<section id="cluster-level-tests">
<h1>Cluster-level Tests<a class="headerlink" href="#cluster-level-tests" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-niseq.cluster_test"></span><dl class="py function">
<dt class="sig sig-object py" id="niseq.cluster_test.sequential_cluster_test_1samp">
<span class="sig-prename descclassname"><span class="pre">niseq.cluster_test.</span></span><span class="sig-name descname"><span class="pre">sequential_cluster_test_1samp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spending_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.cluster_test.sequential_cluster_test_1samp" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequential one-sample cluster test.</p>
<p>A sequential generalization of a one-sample cluster-based permutation test
(as described by [4]) or of TFCE (as described by [6]).</p>
<p>Distributes Type I error over multiple, sequential analyses of the data (at
interim sample sizes specified in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> never to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>)
using a permutation-based adaptation of the alpha-spending procedure introduced
by Lan and DeMets [1]. This allows data collection to be terminated before
<code class="docutils literal notranslate"><span class="pre">max_n</span></code> is reached if there is enough evidence to reject the null hypothesis
at an interim analysis, without inflating the false positive rate. This provides
a principled way to determine sample size and can result in substantial
efficiency gains over a fixed-sample design (i.e. can acheive the same
statistical power with a smaller expected sample size) [2, 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>, </em><em>p</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data to be analyzed. The first dimension of the array is the number of
observations; remaining dimensions comprise the size of a single observation.
Observations must appear in the order in which they were collected.
Note: that the last dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> should correspond to the dimension
represented in the adjacency parameter (e.g., spectral data should be
provided as <code class="docutils literal notranslate"><span class="pre">(observations,</span> <span class="pre">frequencies,</span> <span class="pre">channels/vertices))</span></code>.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default: 0.05</em>) – Desired false positive rate after all looks at the data (i.e. at <code class="docutils literal notranslate"><span class="pre">n_max</span></code>)</p></li>
<li><p><strong>tail</strong> (<em>-1</em><em> or </em><em>0</em><em> or </em><em>1</em><em>, </em><em>default: 0</em>) – If tail is 1, the alternative hypothesis is that the
mean of the data is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the mean of the data is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the mean of the data is less than 0 (lower tailed test).</p></li>
<li><p><strong>spending_func</strong> (<em>instance of SpendingFunction</em><em>, </em><em>default: LinearSpendingFunction</em>) – An initialized instance of one of <code class="docutils literal notranslate"><span class="pre">SpendingFunction</span></code>’s subclasses. This
defines a monotonically increasing function such that f(0) = 0 and
f(n_max) = alpha, determining how Type I error is distributed over
sequential analyses. See [2, 3] for details and provided spending functions
in <code class="docutils literal notranslate"><span class="pre">niseq.spending_functions</span></code> module.</p></li>
<li><p><strong>threshold</strong> (<em>float | dict | None</em><em>, </em><em>default: None</em>) – The so-called “cluster forming threshold” in the form of a test statistic
(note: this is not an alpha level / “p-value”).
If numeric, vertices with data values more extreme than <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will
be used to form clusters. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, threshold will be chosen
automatically to correspond to a p-value of 0.05 for the given number of
observations (only valid when using default statistic). If <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is
a <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> (with keys <code class="docutils literal notranslate"><span class="pre">'start'</span></code> and <code class="docutils literal notranslate"><span class="pre">'step'</span></code>) then threshold-free
cluster enhancement (TFCE) will be used (see TFCE example and [6]).</p></li>
<li><p><strong>n_permutations</strong> (<em>int</em><em>, </em><em>default: 1024</em>) – Number of permutations.</p></li>
<li><p><strong>stat_fun</strong> (<em>callable | None</em>) – Function called to calculate the test statistic. Must accept 1D-array as
input and return a 1D array. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), uses
<cite>mne.stats.ttest_1samp_no_p</cite>.</p></li>
<li><p><strong>adjacency</strong> (<em>scipy.sparse.spmatrix | None | False</em>) – Defines adjacency between locations in the data, where “locations” can be
spatial vertices, frequency bins, time points, etc. For spatial vertices,
see: <code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.find_ch_adjacency()</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, assumes
no adjacency (each location is treated as independent and unconnected).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a regular lattice adjacency is assumed, connecting
each  location to its neighbor(s) along the last dimension
of  <code class="docutils literal notranslate"><span class="pre">X</span></code> (or the last two dimensions if <code class="docutils literal notranslate"><span class="pre">X</span></code> is 2D).
If <code class="docutils literal notranslate"><span class="pre">adjacency</span></code> is a matrix, it is assumed to be symmetric (only the
upper triangular half is used) and must be square with dimension equal to
<code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span></code> (for 2D data) or <code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span> <span class="pre">*</span> <span class="pre">X.shape[-2]</span></code>
(for 3D data) or (optionally)
<code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span> <span class="pre">*</span> <span class="pre">X.shape[-2]</span> <span class="pre">*</span> <span class="pre">X.shape[-3]</span></code>
(for 4D data). The function <cite>mne.stats.combine_adjacency</cite> may be useful for 4D data.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
<li><p><strong>max_step</strong> (<em>int</em>) – Maximum distance between samples along the second axis of <code class="docutils literal notranslate"><span class="pre">X</span></code> to be
considered adjacent (typically the second axis is the “time” dimension).
Only used when <code class="docutils literal notranslate"><span class="pre">adjacency</span></code> has shape (n_vertices, n_vertices), that is,
when adjacency is only specified for sensors (e.g., via
<code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.find_ch_adjacency()</span></code>), and not via sensors <strong>and</strong>
further dimensions such as time points (e.g., via an additional call of
<code class="xref py py-func docutils literal notranslate"><span class="pre">mne.stats.combine_adjacency()</span></code>).</p></li>
<li><p><strong>exclude</strong> (<em>bool array</em><em> or </em><em>None</em>) – Mask to apply to the data to exclude certain points from clustering
(e.g., medial wall vertices). Should be the same shape as <code class="docutils literal notranslate"><span class="pre">X</span></code>.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no points are excluded.</p></li>
<li><p><strong>t_power</strong> (<em>float</em>) – Power to raise the statistical values (usually t-values) by before
summing (sign will be retained). Note that <code class="docutils literal notranslate"><span class="pre">t_power=0</span></code> will give a
count of locations in each cluster, <code class="docutils literal notranslate"><span class="pre">t_power=1</span></code> will weight each location
by its statistical score.</p></li>
<li><p><strong>out_type</strong> (<em>'mask' | 'indices'</em>) – Output format of clusters within a list.
If <code class="docutils literal notranslate"><span class="pre">'mask'</span></code>, returns a list of boolean arrays,
each with the same shape as the input data (or slices if the shape is 1D
and adjacency is None), with <code class="docutils literal notranslate"><span class="pre">True</span></code> values indicating locations that are
part of a cluster. If <code class="docutils literal notranslate"><span class="pre">'indices'</span></code>, returns a list of tuple of ndarray,
where each ndarray contains the indices of locations that together form the
given cluster along the given dimension. Note that for large datasets,
<code class="docutils literal notranslate"><span class="pre">'indices'</span></code> may use far less memory than <code class="docutils literal notranslate"><span class="pre">'mask'</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">'indices'</span></code>.</p></li>
<li><p><strong>check_disjoint</strong> (<em>bool</em>) – Whether to check if the connectivity matrix can be separated into disjoint
sets before clustering. This may lead to faster clustering, especially if
the second dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> (usually the “time” dimension) is large.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>looks</strong> (<em>dict</em>) – Dictionary containing results of each look at the data, indexed by the
values provided in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. Each entry of the dictionary contains:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obs</span></code><span class="classifier">array, shape (p[, q][, r])</span></dt><dd><p>Statistic observed for all variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clusters</span></code><span class="classifier">list</span></dt><dd><p>List type defined by out_type above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cluster_pv</span></code><span class="classifier">array</span></dt><dd><p>P-value for each cluster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H0</span></code><span class="classifier">array, shape (n_permutations,)</span></dt><dd><p>Max cluster level stats observed under permutation.</p>
</dd>
</dl>
</li>
<li><p><strong>ps</strong> (<em>array, shape (n_looks,)</em>) – The lowest p-value obtained at each look specied in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. These
can be compared to <code class="docutils literal notranslate"><span class="pre">adj_alphas</span></code> to determine on which looks, if any, one
can reject the null hypothesis.</p></li>
<li><p><strong>adj_alphas</strong> (<em>array, shape (n_looks,)</em>) – The adjusted significance thresholds for each look, chosen to control the
false positive rate across multiple, sequential analyses. All p-values
should be compared to the adjusted alpha for the look at which they were
computed.</p></li>
<li><p><strong>spending</strong> (<em>array, shape (n_looks,)</em>) – The value of the alpha spending function at each look.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of and timing of looks at the data need not be planned in advance
(other than <code class="docutils literal notranslate"><span class="pre">n_max</span></code>), but it is important to include all looks that have
already occured in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> each time you analyze the data to ensure that
valid adjusted significance thresholds are computed. In your final analysis,
<code class="docutils literal notranslate"><span class="pre">look_times</span></code> should contain the ordered sample sizes at all looks at the data
that occured during the study.</p>
<p>When reporting results, you should minimally include the sample sizes at each
look, the minimum p-values at each look, the adjusted significance thresholds
for each look (to which the p-values are compared), and the value of the
alpha-spending function at each look. See [3] for further recommendations.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span></dt>
<dd><p>Gordon Lan, K. K., &amp; DeMets, D. L. (1983).
Discrete sequential boundaries for clinical trials.
Biometrika, 70(3), 659-663.</p>
</dd>
<dt class="label" id="id2"><span class="brackets">2</span></dt>
<dd><p>Lakens, D. (2014). Performing high-powered studies efficiently with
sequential analyses. European Journal of Social Psychology, 44(7), 701-710.</p>
</dd>
<dt class="label" id="id3"><span class="brackets">3</span></dt>
<dd><p>Lakens, D., Pahlke, F., &amp; Wassmer, G. (2021).
Group Sequential Designs: A Tutorial.
<a class="reference external" href="https://doi.org/10.31234/osf.io/x4azm">https://doi.org/10.31234/osf.io/x4azm</a></p>
</dd>
<dt class="label" id="id4"><span class="brackets">4</span></dt>
<dd><p>Maris, E., &amp; Oostenveld, R. (2007). Nonparametric statistical testing of
EEG-and MEG-data. Journal of neuroscience methods, 164(1), 177-190.</p>
</dd>
<dt class="label" id="id5"><span class="brackets">5</span></dt>
<dd><p>Jona Sassenhagen and Dejan Draschkow. Cluster-based permutation tests of
meg/eeg data do not establish significance of effect latency or location.
Psychophysiology, 56(6):e13335, 2019. doi:10.1111/psyp.13335.</p>
</dd>
<dt class="label" id="id6"><span class="brackets">6</span></dt>
<dd><p>Stephen M. Smith and Thomas E. Nichols. Threshold-free cluster
enhancement: addressing problems of smoothing, threshold dependence and
localisation in cluster inference.
NeuroImage, 44(1):83–98, 2009. doi:10.1016/j.neuroimage.2008.03.061.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="niseq.cluster_test.sequential_cluster_test_corr">
<span class="sig-prename descclassname"><span class="pre">niseq.cluster_test.</span></span><span class="sig-name descname"><span class="pre">sequential_cluster_test_corr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spending_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.cluster_test.sequential_cluster_test_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequential cluster test for correlations.</p>
<p>A sequential generalization of a cluster-based permutation test
(as described by [4]) or of TFCE (as described by [6]) for testing a
relationship between <code class="docutils literal notranslate"><span class="pre">X</span></code> and a continuous variable <code class="docutils literal notranslate"><span class="pre">y</span></code>. Uses Pearson
correlation by default (or its z-transform if using TFCE), but test
statistic can be modified.</p>
<p>Distributes Type I error over multiple, sequential analyses of the data (at
interim sample sizes specified in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> never to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>)
using a permutation-based adaptation of the alpha-spending procedure introduced
by Lan and DeMets [1]. This allows data collection to be terminated before
<code class="docutils literal notranslate"><span class="pre">max_n</span></code> is reached if there is enough evidence to reject the null hypothesis
at an interim analysis, without inflating the false positive rate. This provides
a principled way to determine sample size and can result in substantial
efficiency gains over a fixed-sample design (i.e. can acheive the same
statistical power with a smaller expected sample size) [2, 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>, </em><em>p</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data to be analyzed. The first dimension of the array is the number of
observations; remaining dimensions comprise the size of a single observation.
Observations must appear in the order in which they were collected.
Note: that the last dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> should correspond to the dimension
represented in the adjacency parameter (e.g., spectral data should be
provided as <code class="docutils literal notranslate"><span class="pre">(observations,</span> <span class="pre">frequencies,</span> <span class="pre">channels/vertices))</span></code>.</p></li>
<li><p><strong>y</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>,</em><em>)</em>) – Value of dependent variable associated with each observation in <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default: 0.05</em>) – Desired false positive rate after all looks at the data (i.e. at <code class="docutils literal notranslate"><span class="pre">n_max</span></code>)</p></li>
<li><p><strong>tail</strong> (<em>-1</em><em> or </em><em>0</em><em> or </em><em>1</em><em>, </em><em>default: 0</em>) – If tail is 1, the alternative hypothesis is that the
mean of the data is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the mean of the data is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the mean of the data is less than 0 (lower tailed test).</p></li>
<li><p><strong>spending_func</strong> (<em>instance of SpendingFunction</em><em>, </em><em>default: LinearSpendingFunction</em>) – An initialized instance of one of <code class="docutils literal notranslate"><span class="pre">SpendingFunction</span></code>’s subclasses. This
defines a monotonically increasing function such that f(0) = 0 and
f(n_max) = alpha, determining how Type I error is distributed over
sequential analyses. See [2, 3] for details and provided spending functions
in <code class="docutils literal notranslate"><span class="pre">niseq.spending_functions</span></code> module.</p></li>
<li><p><strong>threshold</strong> (<em>float | dict | None</em><em>, </em><em>default: None</em>) – The so-called “cluster forming threshold” in the form of a test statistic
(note: this is not an alpha level / “p-value”).
If numeric, vertices with data values more extreme than <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will
be used to form clusters. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, threshold will be chosen
automatically to correspond to a p-value of 0.05 for the given number of
observations (only valid when using default statistic). If <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is
a <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> (with keys <code class="docutils literal notranslate"><span class="pre">'start'</span></code> and <code class="docutils literal notranslate"><span class="pre">'step'</span></code>) then threshold-free
cluster enhancement (TFCE) will be used (see TFCE example and [6]).</p></li>
<li><p><strong>n_permutations</strong> (<em>int</em><em>, </em><em>default: 1024</em>) – Number of permutations.</p></li>
<li><p><strong>tail</strong> – If tail is 1, the alternative hypothesis is that the
correlation is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the correlation is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the correlation is less than 0 (lower tailed test).</p></li>
<li><p><strong>stat_fun</strong> (<em>callable</em><em>(</em><em>) </em><em>| None</em><em>, </em><em>default: None</em>) – Function called to calculate the test statistic. Must accept 1D-array as
input and return a 1D array. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), computes Pearson
correlation.</p></li>
<li><p><strong>adjacency</strong> (<em>scipy.sparse.spmatrix | None | False</em>) – Defines adjacency between locations in the data, where “locations” can be
spatial vertices, frequency bins, time points, etc. For spatial vertices,
see: <code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.find_ch_adjacency()</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, assumes
no adjacency (each location is treated as independent and unconnected).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a regular lattice adjacency is assumed, connecting
each  location to its neighbor(s) along the last dimension
of  <code class="docutils literal notranslate"><span class="pre">X</span></code> (or the last two dimensions if <code class="docutils literal notranslate"><span class="pre">X</span></code> is 2D).
If <code class="docutils literal notranslate"><span class="pre">adjacency</span></code> is a matrix, it is assumed to be symmetric (only the
upper triangular half is used) and must be square with dimension equal to
<code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span></code> (for 2D data) or <code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span> <span class="pre">*</span> <span class="pre">X.shape[-2]</span></code>
(for 3D data) or (optionally)
<code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span> <span class="pre">*</span> <span class="pre">X.shape[-2]</span> <span class="pre">*</span> <span class="pre">X.shape[-3]</span></code>
(for 4D data). The function <cite>mne.stats.combine_adjacency</cite> may be useful for 4D data.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
<li><p><strong>max_step</strong> (<em>int</em>) – Maximum distance between samples along the second axis of <code class="docutils literal notranslate"><span class="pre">X</span></code> to be
considered adjacent (typically the second axis is the “time” dimension).
Only used when <code class="docutils literal notranslate"><span class="pre">adjacency</span></code> has shape (n_vertices, n_vertices), that is,
when adjacency is only specified for sensors (e.g., via
<code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.find_ch_adjacency()</span></code>), and not via sensors <strong>and</strong>
further dimensions such as time points (e.g., via an additional call of
<code class="xref py py-func docutils literal notranslate"><span class="pre">mne.stats.combine_adjacency()</span></code>).</p></li>
<li><p><strong>exclude</strong> (<em>bool array</em><em> or </em><em>None</em>) – Mask to apply to the data to exclude certain points from clustering
(e.g., medial wall vertices). Should be the same shape as <code class="docutils literal notranslate"><span class="pre">X</span></code>.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no points are excluded.</p></li>
<li><p><strong>t_power</strong> (<em>float</em>) – Power to raise the statistical values (usually F-values) by before
summing (sign will be retained). Note that <code class="docutils literal notranslate"><span class="pre">t_power=0</span></code> will give a
count of locations in each cluster, <code class="docutils literal notranslate"><span class="pre">t_power=1</span></code> will weight each location
by its statistical score.</p></li>
<li><p><strong>out_type</strong> (<em>'mask' | 'indices'</em>) – Output format of clusters within a list.
If <code class="docutils literal notranslate"><span class="pre">'mask'</span></code>, returns a list of boolean arrays,
each with the same shape as the input data (or slices if the shape is 1D
and adjacency is None), with <code class="docutils literal notranslate"><span class="pre">True</span></code> values indicating locations that are
part of a cluster. If <code class="docutils literal notranslate"><span class="pre">'indices'</span></code>, returns a list of tuple of ndarray,
where each ndarray contains the indices of locations that together form the
given cluster along the given dimension. Note that for large datasets,
<code class="docutils literal notranslate"><span class="pre">'indices'</span></code> may use far less memory than <code class="docutils literal notranslate"><span class="pre">'mask'</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">'indices'</span></code>.</p></li>
<li><p><strong>check_disjoint</strong> (<em>bool</em>) – Whether to check if the connectivity matrix can be separated into disjoint
sets before clustering. This may lead to faster clustering, especially if
the second dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> (usually the “time” dimension) is large.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>looks</strong> (<em>dict</em>) – Dictionary containing results of each look at the data, indexed by the
values provided in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. Each entry of the dictionary contains:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obs</span></code><span class="classifier">array, shape (p[, q][, r])</span></dt><dd><p>Statistic observed for all variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clusters</span></code><span class="classifier">list</span></dt><dd><p>List type defined by out_type above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cluster_pv</span></code><span class="classifier">array</span></dt><dd><p>P-value for each cluster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H0</span></code><span class="classifier">array, shape (n_permutations,)</span></dt><dd><p>Max cluster level stats observed under permutation.</p>
</dd>
</dl>
</li>
<li><p><strong>ps</strong> (<em>array, shape (n_looks,)</em>) – The lowest p-value obtained at each look specied in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. These
can be compared to <code class="docutils literal notranslate"><span class="pre">adj_alphas</span></code> to determine on which looks, if any, one
can reject the null hypothesis.</p></li>
<li><p><strong>adj_alphas</strong> (<em>array, shape (n_looks,)</em>) – The adjusted significance thresholds for each look, chosen to control the
false positive rate across multiple, sequential analyses. All p-values
should be compared to the adjusted alpha for the look at which they were
computed.</p></li>
<li><p><strong>spending</strong> (<em>array, shape (n_looks,)</em>) – The value of the alpha spending function at each look.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of and timing of looks at the data need not be planned in advance
(other than <code class="docutils literal notranslate"><span class="pre">n_max</span></code>), but it is important to include all looks that have
already occured in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> each time you analyze the data to ensure that
valid adjusted significance thresholds are computed. In your final analysis,
<code class="docutils literal notranslate"><span class="pre">look_times</span></code> should contain the ordered sample sizes at all looks at the data
that occured during the study.</p>
<p>When reporting results, you should minimally include the sample sizes at each
look, the minimum p-values at each look, the adjusted significance thresholds
for each look (to which the p-values are compared), and the value of the
alpha-spending function at each look. See [3] for further recommendations.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets">1</span></dt>
<dd><p>Gordon Lan, K. K., &amp; DeMets, D. L. (1983).
Discrete sequential boundaries for clinical trials.
Biometrika, 70(3), 659-663.</p>
</dd>
<dt class="label" id="id8"><span class="brackets">2</span></dt>
<dd><p>Lakens, D. (2014). Performing high-powered studies efficiently with
sequential analyses. European Journal of Social Psychology, 44(7), 701-710.</p>
</dd>
<dt class="label" id="id9"><span class="brackets">3</span></dt>
<dd><p>Lakens, D., Pahlke, F., &amp; Wassmer, G. (2021).
Group Sequential Designs: A Tutorial.
<a class="reference external" href="https://doi.org/10.31234/osf.io/x4azm">https://doi.org/10.31234/osf.io/x4azm</a></p>
</dd>
<dt class="label" id="id10"><span class="brackets">4</span></dt>
<dd><p>Maris, E., &amp; Oostenveld, R. (2007). Nonparametric statistical testing of
EEG-and MEG-data. Journal of neuroscience methods, 164(1), 177-190.</p>
</dd>
<dt class="label" id="id11"><span class="brackets">5</span></dt>
<dd><p>Jona Sassenhagen and Dejan Draschkow. Cluster-based permutation tests of
meg/eeg data do not establish significance of effect latency or location.
Psychophysiology, 56(6):e13335, 2019. doi:10.1111/psyp.13335.</p>
</dd>
<dt class="label" id="id12"><span class="brackets">6</span></dt>
<dd><p>Stephen M. Smith and Thomas E. Nichols. Threshold-free cluster
enhancement: addressing problems of smoothing, threshold dependence and
localisation in cluster inference.
NeuroImage, 44(1):83–98, 2009. doi:10.1016/j.neuroimage.2008.03.061.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="niseq.cluster_test.sequential_cluster_test_indep">
<span class="sig-prename descclassname"><span class="pre">niseq.cluster_test.</span></span><span class="sig-name descname"><span class="pre">sequential_cluster_test_indep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spending_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.cluster_test.sequential_cluster_test_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequential independent-sample cluster test.</p>
<p>A sequential generalization of an independet-sample cluster-based
permutation test (as described by [4]) or of TFCE (as described by [6]).</p>
<p>Distributes Type I error over multiple, sequential analyses of the data (at
interim sample sizes specified in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> never to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>)
using a permutation-based adaptation of the alpha-spending procedure introduced
by Lan and DeMets [1]. This allows data collection to be terminated before
<code class="docutils literal notranslate"><span class="pre">max_n</span></code> is reached if there is enough evidence to reject the null hypothesis
at an interim analysis, without inflating the false positive rate. This provides
a principled way to determine sample size and can result in substantial
efficiency gains over a fixed-sample design (i.e. can acheive the same
statistical power with a smaller expected sample size) [2, 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>, </em><em>p</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data to be analyzed. The first dimension of the array is the number of
observations; remaining dimensions comprise the size of a single observation.
Observations must appear in the order in which they were collected.
Note: that the last dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> should correspond to the dimension
represented in the adjacency parameter (e.g., spectral data should be
provided as <code class="docutils literal notranslate"><span class="pre">(observations,</span> <span class="pre">frequencies,</span> <span class="pre">channels/vertices))</span></code>.</p></li>
<li><p><strong>labels</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>,</em><em>)</em>) – Condition label associated with each observation in <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default: 0.05</em>) – Desired false positive rate after all looks at the data (i.e. at <code class="docutils literal notranslate"><span class="pre">n_max</span></code>)</p></li>
<li><p><strong>tail</strong> (<em>-1</em><em> or </em><em>0</em><em> or </em><em>1</em><em>, </em><em>default: 0</em>) – If tail is 1, the statistic is thresholded above threshold.
If tail is -1, the statistic is thresholded below threshold.
If tail is 0, the statistic is thresholded on both sides of
the distribution.</p></li>
<li><p><strong>spending_func</strong> (<em>instance of SpendingFunction</em><em>, </em><em>default: LinearSpendingFunction</em>) – An initialized instance of one of <code class="docutils literal notranslate"><span class="pre">SpendingFunction</span></code>’s subclasses. This
defines a monotonically increasing function such that f(0) = 0 and
f(n_max) = alpha, determining how Type I error is distributed over
sequential analyses. See [2, 3] for details and provided spending functions
in <code class="docutils literal notranslate"><span class="pre">niseq.spending_functions</span></code> module.</p></li>
<li><p><strong>threshold</strong> (<em>float | dict | None</em><em>, </em><em>default: None</em>) – The so-called “cluster forming threshold” in the form of a test statistic
(note: this is not an alpha level / “p-value”).
If numeric, vertices with data values more extreme than <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will
be used to form clusters. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, threshold will be chosen
automatically to correspond to a p-value of 0.05 for the given number of
observations (only valid when using default statistic). If <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is
a <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> (with keys <code class="docutils literal notranslate"><span class="pre">'start'</span></code> and <code class="docutils literal notranslate"><span class="pre">'step'</span></code>) then threshold-free
cluster enhancement (TFCE) will be used (see TFCE example and [6]).</p></li>
<li><p><strong>n_permutations</strong> (<em>int</em><em>, </em><em>default: 1024</em>) – Number of permutations.</p></li>
<li><p><strong>tail</strong> – If tail is 1, the alternative hypothesis is that the
mean of the data is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the mean of the data is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the mean of the data is less than 0 (lower tailed test).</p></li>
<li><p><strong>stat_fun</strong> (<em>callable | None</em>) – Function called to calculate the test statistic. Must accept 1D-array as
input and return a 1D array. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), uses
<cite>mne.stats.f_oneway</cite>.</p></li>
<li><p><strong>adjacency</strong> (<em>scipy.sparse.spmatrix | None | False</em>) – Defines adjacency between locations in the data, where “locations” can be
spatial vertices, frequency bins, time points, etc. For spatial vertices,
see: <code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.find_ch_adjacency()</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, assumes
no adjacency (each location is treated as independent and unconnected).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a regular lattice adjacency is assumed, connecting
each  location to its neighbor(s) along the last dimension
of  <code class="docutils literal notranslate"><span class="pre">X</span></code> (or the last two dimensions if <code class="docutils literal notranslate"><span class="pre">X</span></code> is 2D).
If <code class="docutils literal notranslate"><span class="pre">adjacency</span></code> is a matrix, it is assumed to be symmetric (only the
upper triangular half is used) and must be square with dimension equal to
<code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span></code> (for 2D data) or <code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span> <span class="pre">*</span> <span class="pre">X.shape[-2]</span></code>
(for 3D data) or (optionally)
<code class="docutils literal notranslate"><span class="pre">X.shape[-1]</span> <span class="pre">*</span> <span class="pre">X.shape[-2]</span> <span class="pre">*</span> <span class="pre">X.shape[-3]</span></code>
(for 4D data). The function <cite>mne.stats.combine_adjacency</cite> may be useful for 4D data.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
<li><p><strong>max_step</strong> (<em>int</em>) – Maximum distance between samples along the second axis of <code class="docutils literal notranslate"><span class="pre">X</span></code> to be
considered adjacent (typically the second axis is the “time” dimension).
Only used when <code class="docutils literal notranslate"><span class="pre">adjacency</span></code> has shape (n_vertices, n_vertices), that is,
when adjacency is only specified for sensors (e.g., via
<code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.find_ch_adjacency()</span></code>), and not via sensors <strong>and</strong>
further dimensions such as time points (e.g., via an additional call of
<code class="xref py py-func docutils literal notranslate"><span class="pre">mne.stats.combine_adjacency()</span></code>).</p></li>
<li><p><strong>exclude</strong> (<em>bool array</em><em> or </em><em>None</em>) – Mask to apply to the data to exclude certain points from clustering
(e.g., medial wall vertices). Should be the same shape as <code class="docutils literal notranslate"><span class="pre">X</span></code>.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no points are excluded.</p></li>
<li><p><strong>t_power</strong> (<em>float</em>) – Power to raise the statistical values (usually F-values) by before
summing (sign will be retained). Note that <code class="docutils literal notranslate"><span class="pre">t_power=0</span></code> will give a
count of locations in each cluster, <code class="docutils literal notranslate"><span class="pre">t_power=1</span></code> will weight each location
by its statistical score.</p></li>
<li><p><strong>out_type</strong> (<em>'mask' | 'indices'</em>) – Output format of clusters within a list.
If <code class="docutils literal notranslate"><span class="pre">'mask'</span></code>, returns a list of boolean arrays,
each with the same shape as the input data (or slices if the shape is 1D
and adjacency is None), with <code class="docutils literal notranslate"><span class="pre">True</span></code> values indicating locations that are
part of a cluster. If <code class="docutils literal notranslate"><span class="pre">'indices'</span></code>, returns a list of tuple of ndarray,
where each ndarray contains the indices of locations that together form the
given cluster along the given dimension. Note that for large datasets,
<code class="docutils literal notranslate"><span class="pre">'indices'</span></code> may use far less memory than <code class="docutils literal notranslate"><span class="pre">'mask'</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">'indices'</span></code>.</p></li>
<li><p><strong>check_disjoint</strong> (<em>bool</em>) – Whether to check if the connectivity matrix can be separated into disjoint
sets before clustering. This may lead to faster clustering, especially if
the second dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> (usually the “time” dimension) is large.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>looks</strong> (<em>dict</em>) – Dictionary containing results of each look at the data, indexed by the
values provided in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. Each entry of the dictionary contains:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obs</span></code><span class="classifier">array, shape (p[, q][, r])</span></dt><dd><p>Statistic observed for all variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clusters</span></code><span class="classifier">list</span></dt><dd><p>List type defined by out_type above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cluster_pv</span></code><span class="classifier">array</span></dt><dd><p>P-value for each cluster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H0</span></code><span class="classifier">array, shape (n_permutations,)</span></dt><dd><p>Max cluster level stats observed under permutation.</p>
</dd>
</dl>
</li>
<li><p><strong>ps</strong> (<em>array, shape (n_looks,)</em>) – The lowest p-value obtained at each look specied in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. These
can be compared to <code class="docutils literal notranslate"><span class="pre">adj_alphas</span></code> to determine on which looks, if any, one
can reject the null hypothesis.</p></li>
<li><p><strong>adj_alphas</strong> (<em>array, shape (n_looks,)</em>) – The adjusted significance thresholds for each look, chosen to control the
false positive rate across multiple, sequential analyses. All p-values
should be compared to the adjusted alpha for the look at which they were
computed.</p></li>
<li><p><strong>spending</strong> (<em>array, shape (n_looks,)</em>) – The value of the alpha spending function at each look.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of and timing of looks at the data need not be planned in advance
(other than <code class="docutils literal notranslate"><span class="pre">n_max</span></code>), but it is important to include all looks that have
already occured in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> each time you analyze the data to ensure that
valid adjusted significance thresholds are computed. In your final analysis,
<code class="docutils literal notranslate"><span class="pre">look_times</span></code> should contain the ordered sample sizes at all looks at the data
that occured during the study.</p>
<p>When reporting results, you should minimally include the sample sizes at each
look, the minimum p-values at each look, the adjusted significance thresholds
for each look (to which the p-values are compared), and the value of the
alpha-spending function at each look. See [3] for further recommendations.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets">1</span></dt>
<dd><p>Gordon Lan, K. K., &amp; DeMets, D. L. (1983).
Discrete sequential boundaries for clinical trials.
Biometrika, 70(3), 659-663.</p>
</dd>
<dt class="label" id="id14"><span class="brackets">2</span></dt>
<dd><p>Lakens, D. (2014). Performing high-powered studies efficiently with
sequential analyses. European Journal of Social Psychology, 44(7), 701-710.</p>
</dd>
<dt class="label" id="id15"><span class="brackets">3</span></dt>
<dd><p>Lakens, D., Pahlke, F., &amp; Wassmer, G. (2021).
Group Sequential Designs: A Tutorial.
<a class="reference external" href="https://doi.org/10.31234/osf.io/x4azm">https://doi.org/10.31234/osf.io/x4azm</a></p>
</dd>
<dt class="label" id="id16"><span class="brackets">4</span></dt>
<dd><p>Maris, E., &amp; Oostenveld, R. (2007). Nonparametric statistical testing of
EEG-and MEG-data. Journal of neuroscience methods, 164(1), 177-190.</p>
</dd>
<dt class="label" id="id17"><span class="brackets">5</span></dt>
<dd><p>Jona Sassenhagen and Dejan Draschkow. Cluster-based permutation tests of
meg/eeg data do not establish significance of effect latency or location.
Psychophysiology, 56(6):e13335, 2019. doi:10.1111/psyp.13335.</p>
</dd>
<dt class="label" id="id18"><span class="brackets">6</span></dt>
<dd><p>Stephen M. Smith and Thomas E. Nichols. Threshold-free cluster
enhancement: addressing problems of smoothing, threshold dependence and
localisation in cluster inference.
NeuroImage, 44(1):83–98, 2009. doi:10.1016/j.neuroimage.2008.03.061.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-niseq.max_test">
<span id="max-type-tests"></span><h1>Max-type Tests<a class="headerlink" href="#module-niseq.max_test" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="niseq.max_test.sequential_permutation_t_test_1samp">
<span class="sig-prename descclassname"><span class="pre">niseq.max_test.</span></span><span class="sig-name descname"><span class="pre">sequential_permutation_t_test_1samp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spending_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.max_test.sequential_permutation_t_test_1samp" title="Permalink to this definition">¶</a></dt>
<dd><p>One-sample sequential permutation test with max-type correction.</p>
<p>This is a sequential generalization of
<code class="docutils literal notranslate"><span class="pre">mne.stats.permutations.permutation_t_test</span></code>. There’s also the option to
switch out the test statistic instead of using a t statistic.</p>
<p>Uses max-type correction for multiple comparisons [4].</p>
<p>Distributes Type I error over multiple, sequential analyses of the data (at
interim sample sizes specified in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> never to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>)
using a permutation-based adaptation of the alpha-spending procedure introduced
by Lan and DeMets [1]. This allows data collection to be terminated before
<code class="docutils literal notranslate"><span class="pre">max_n</span></code> is reached if there is enough evidence to reject the null hypothesis
at an interim analysis, without inflating the false positive rate. This provides
a principled way to determine sample size and can result in substantial
efficiency gains over a fixed-sample design (i.e. can acheive the same
statistical power with a smaller expected sample size) [2, 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>[</em><em>, </em><em>p</em><em>]</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data to be analyzed. The first dimension of the array is the number of
observations; remaining dimensions comprise the size of a single observation.
Observations must appear in the order in which they were collected.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default: 0.05</em>) – Desired false positive rate after all looks at the data (i.e. at <code class="docutils literal notranslate"><span class="pre">n_max</span></code>)</p></li>
<li><p><strong>tail</strong> (<em>-1</em><em> or </em><em>0</em><em> or </em><em>1</em><em>, </em><em>default: 0</em>) – If tail is 1, the alternative hypothesis is that the
mean of the data is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the mean of the data is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the mean of the data is less than 0 (lower tailed test).</p></li>
<li><p><strong>spending_func</strong> (<em>instance of SpendingFunction</em><em>, </em><em>default: LinearSpendingFunction</em>) – An initialized instance of one of <code class="docutils literal notranslate"><span class="pre">SpendingFunction</span></code>’s subclasses. This
defines a monotonically increasing function such that f(0) = 0 and
f(n_max) = alpha, determining how Type I error is distributed over
sequential analyses. See [2, 3] for details and provided spending functions
in <code class="docutils literal notranslate"><span class="pre">niseq.spending_functions</span></code> module.</p></li>
<li><p><strong>n_permutations</strong> (<em>int</em><em>, </em><em>default: 1024</em>) – Number of permutations.</p></li>
<li><p><strong>stat_fun</strong> (<em>callable | None</em>) – Function called to calculate the test statistic. Must accept 1D-array as
input and return a 1D array. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), uses
<cite>mne.stats.ttest_1samp_no_p</cite>.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>looks</strong> (<em>dict</em>) – Dictionary containing results of each look at the data, indexed by the
values provided in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. Each entry of the dictionary contains:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obs</span></code><span class="classifier">array of shape (p[, q][, r])</span></dt><dd><p>Test statistic observed for all variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_values</span></code><span class="classifier">array of shape (p[, q][, r])</span></dt><dd><p>P-values for all the tests (a.k.a. variables).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H0</span></code><span class="classifier">array of shape [n_permutations]</span></dt><dd><p>Max test statistics obtained by permutations.</p>
</dd>
</dl>
</li>
<li><p><strong>ps</strong> (<em>array, shape (n_looks,)</em>) – The lowest p-value obtained at each look specied in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. These
can be compared to <code class="docutils literal notranslate"><span class="pre">adj_alphas</span></code> to determine on which looks, if any, one
can reject the null hypothesis.</p></li>
<li><p><strong>adj_alphas</strong> (<em>array, shape (n_looks,)</em>) – The adjusted significance thresholds for each look, chosen to control the
false positive rate across multiple, sequential analyses. All p-values
should be compared to the adjusted alpha for the look at which they were
computed.</p></li>
<li><p><strong>spending</strong> (<em>array, shape (n_looks,)</em>) – The value of the alpha spending function at each look.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of and timing of looks at the data need not be planned in advance
(other than <code class="docutils literal notranslate"><span class="pre">n_max</span></code>), but it is important to include all looks that have
already occured in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> each time you analyze the data to ensure that
valid adjusted significance thresholds are computed. In your final analysis,
<code class="docutils literal notranslate"><span class="pre">look_times</span></code> should contain the ordered sample sizes at all looks at the data
that occured during the study.</p>
<p>When reporting results, you should minimally include the sample sizes at each
look, the minimum p-values at each look, the adjusted significance thresholds
for each look (to which the p-values are compared), and the value of the
alpha-spending function at each look. See [3] for further recommendations.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id19"><span class="brackets">1</span></dt>
<dd><p>Gordon Lan, K. K., &amp; DeMets, D. L. (1983).
Discrete sequential boundaries for clinical trials.
Biometrika, 70(3), 659-663.</p>
</dd>
<dt class="label" id="id20"><span class="brackets">2</span></dt>
<dd><p>Lakens, D. (2014). Performing high‐powered studies efficiently with
sequential analyses. European Journal of Social Psychology, 44(7), 701-710.</p>
</dd>
<dt class="label" id="id21"><span class="brackets">3</span></dt>
<dd><p>Lakens, D., Pahlke, F., &amp; Wassmer, G. (2021).
Group Sequential Designs: A Tutorial.
<a class="reference external" href="https://doi.org/10.31234/osf.io/x4azm">https://doi.org/10.31234/osf.io/x4azm</a></p>
</dd>
<dt class="label" id="id22"><span class="brackets">4</span></dt>
<dd><p>Thomas E. Nichols and Andrew P. Holmes. Nonparametric permutation tests
for functional neuroimaging: a primer with examples.
Human Brain Mapping, 15(1):1–25, 2002. doi:10.1002/hbm.1058.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="niseq.max_test.sequential_permutation_test_corr">
<span class="sig-prename descclassname"><span class="pre">niseq.max_test.</span></span><span class="sig-name descname"><span class="pre">sequential_permutation_test_corr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spending_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.max_test.sequential_permutation_test_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequential permutation test for correlations with a max-type correction.</p>
<p>Tests for a relationship between <code class="docutils literal notranslate"><span class="pre">X</span></code> and a continuous independent variable
<code class="docutils literal notranslate"><span class="pre">y</span></code>. By default, uses Pearson correlation by default, but the test
statistic can be modified.</p>
<p>Uses max-type correction for multiple comparisons [4].</p>
<p>Distributes Type I error over multiple, sequential analyses of the data (at
interim sample sizes specified in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> never to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>)
using a permutation-based adaptation of the alpha-spending procedure introduced
by Lan and DeMets [1]. This allows data collection to be terminated before
<code class="docutils literal notranslate"><span class="pre">max_n</span></code> is reached if there is enough evidence to reject the null hypothesis
at an interim analysis, without inflating the false positive rate. This provides
a principled way to determine sample size and can result in substantial
efficiency gains over a fixed-sample design (i.e. can acheive the same
statistical power with a smaller expected sample size) [2, 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>[</em><em>, </em><em>p</em><em>]</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data to be analyzed. The first dimension of the array is the number of
observations; remaining dimensions comprise the size of a single observation.
Observations must appear in the order in which they were collected.</p></li>
<li><p><strong>y</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>,</em><em>)</em>) – Value of dependent variable associated with each observation in <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default: 0.05</em>) – Desired false positive rate after all looks at the data (i.e. at <code class="docutils literal notranslate"><span class="pre">n_max</span></code>)</p></li>
<li><p><strong>tail</strong> (<em>-1</em><em> or </em><em>0</em><em> or </em><em>1</em><em>, </em><em>default: 0</em>) – If tail is 1, the alternative hypothesis is that the
correlation is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the correlation is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the correlation is less than 0 (lower tailed test).</p></li>
<li><p><strong>spending_func</strong> (<em>instance of SpendingFunction</em><em>, </em><em>default: LinearSpendingFunction</em>) – An initialized instance of one of <code class="docutils literal notranslate"><span class="pre">SpendingFunction</span></code>’s subclasses. This
defines a monotonically increasing function such that f(0) = 0 and
f(n_max) = alpha, determining how Type I error is distributed over
sequential analyses. See [2, 3] for details and provided spending functions
in <code class="docutils literal notranslate"><span class="pre">niseq.spending_functions</span></code> module.</p></li>
<li><p><strong>n_permutations</strong> (<em>int</em><em>, </em><em>default: 1024</em>) – Number of permutations.</p></li>
<li><p><strong>stat_fun</strong> (<em>callable</em><em>(</em><em>) </em><em>| None</em><em>, </em><em>default: None</em>) – Function called to calculate the test statistic. Must accept 1D-array as
input and return a 1D array. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), computes Pearson
correlation.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>looks</strong> (<em>dict</em>) – Dictionary containing results of each look at the data, indexed by the
values provided in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. Each entry of the dictionary contains:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obs</span></code><span class="classifier">array of shape (p[, q][, r])</span></dt><dd><p>Test statistic observed for all variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_values</span></code><span class="classifier">array of shape (p[, q][, r])</span></dt><dd><p>P-values for all the tests (a.k.a. variables).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H0</span></code><span class="classifier">array of shape [n_permutations]</span></dt><dd><p>Max test statistics obtained by permutations.</p>
</dd>
</dl>
</li>
<li><p><strong>ps</strong> (<em>array, shape (n_looks,)</em>) – The lowest p-value obtained at each look specied in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. These
can be compared to <code class="docutils literal notranslate"><span class="pre">adj_alphas</span></code> to determine on which looks, if any, one
can reject the null hypothesis.</p></li>
<li><p><strong>adj_alphas</strong> (<em>array, shape (n_looks,)</em>) – The adjusted significance thresholds for each look, chosen to control the
false positive rate across multiple, sequential analyses. All p-values
should be compared to the adjusted alpha for the look at which they were
computed.</p></li>
<li><p><strong>spending</strong> (<em>array, shape (n_looks,)</em>) – The value of the alpha spending function at each look.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of and timing of looks at the data need not be planned in advance
(other than <code class="docutils literal notranslate"><span class="pre">n_max</span></code>), but it is important to include all looks that have
already occured in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> each time you analyze the data to ensure that
valid adjusted significance thresholds are computed. In your final analysis,
<code class="docutils literal notranslate"><span class="pre">look_times</span></code> should contain the ordered sample sizes at all looks at the data
that occured during the study.</p>
<p>When reporting results, you should minimally include the sample sizes at each
look, the minimum p-values at each look, the adjusted significance thresholds
for each look (to which the p-values are compared), and the value of the
alpha-spending function at each look. See [3] for further recommendations.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id23"><span class="brackets">1</span></dt>
<dd><p>Gordon Lan, K. K., &amp; DeMets, D. L. (1983).
Discrete sequential boundaries for clinical trials.
Biometrika, 70(3), 659-663.</p>
</dd>
<dt class="label" id="id24"><span class="brackets">2</span></dt>
<dd><p>Lakens, D. (2014). Performing high‐powered studies efficiently with
sequential analyses. European Journal of Social Psychology, 44(7), 701-710.</p>
</dd>
<dt class="label" id="id25"><span class="brackets">3</span></dt>
<dd><p>Lakens, D., Pahlke, F., &amp; Wassmer, G. (2021).
Group Sequential Designs: A Tutorial.
<a class="reference external" href="https://doi.org/10.31234/osf.io/x4azm">https://doi.org/10.31234/osf.io/x4azm</a></p>
</dd>
<dt class="label" id="id26"><span class="brackets">4</span></dt>
<dd><p>Thomas E. Nichols and Andrew P. Holmes. Nonparametric permutation tests
for functional neuroimaging: a primer with examples.
Human Brain Mapping, 15(1):1–25, 2002. doi:10.1002/hbm.1058.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="niseq.max_test.sequential_permutation_test_indep">
<span class="sig-prename descclassname"><span class="pre">niseq.max_test.</span></span><span class="sig-name descname"><span class="pre">sequential_permutation_test_indep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spending_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.max_test.sequential_permutation_test_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>Independent-sample sequential permutation test with max-type correction.</p>
<p>By default, this is a sequential generalization of an independent sample
max-t procedure if two groups and max-F procedure if more groups. However,
there’s an option to switch out the test statistic.</p>
<p>Uses max-type correction for multiple comparisons [4].</p>
<p>Distributes Type I error over multiple, sequential analyses of the data (at
interim sample sizes specified in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> never to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>)
using a permutation-based adaptation of the alpha-spending procedure introduced
by Lan and DeMets [1]. This allows data collection to be terminated before
<code class="docutils literal notranslate"><span class="pre">max_n</span></code> is reached if there is enough evidence to reject the null hypothesis
at an interim analysis, without inflating the false positive rate. This provides
a principled way to determine sample size and can result in substantial
efficiency gains over a fixed-sample design (i.e. can acheive the same
statistical power with a smaller expected sample size) [2, 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>[</em><em>, </em><em>p</em><em>]</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data to be analyzed. The first dimension of the array is the number of
observations; remaining dimensions comprise the size of a single observation.
Observations must appear in the order in which they were collected.</p></li>
<li><p><strong>labels</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>,</em><em>)</em>) – Condition label associated with each observation in <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default: 0.05</em>) – Desired false positive rate after all looks at the data (i.e. at <code class="docutils literal notranslate"><span class="pre">n_max</span></code>)</p></li>
<li><p><strong>tail</strong> (<em>-1</em><em> or </em><em>0</em><em> or </em><em>1</em><em>, </em><em>default: 0</em>) – If tail is 1, the alternative hypothesis is that the
mean of the data is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the mean of the data is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the mean of the data is less than 0 (lower tailed test).</p></li>
<li><p><strong>spending_func</strong> (<em>instance of SpendingFunction</em><em>, </em><em>default: LinearSpendingFunction</em>) – An initialized instance of one of <code class="docutils literal notranslate"><span class="pre">SpendingFunction</span></code>’s subclasses. This
defines a monotonically increasing function such that f(0) = 0 and
f(n_max) = alpha, determining how Type I error is distributed over
sequential analyses. See [2, 3] for details and provided spending functions
in <code class="docutils literal notranslate"><span class="pre">niseq.spending_functions</span></code> module.</p></li>
<li><p><strong>n_permutations</strong> (<em>int</em><em>, </em><em>default: 1024</em>) – Number of permutations.</p></li>
<li><p><strong>stat_fun</strong> (<em>callable | None</em>) – Function called to calculate the test statistic. Must accept 1D-array as
input and return a 1D array. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), uses
<cite>mne.stats.f_oneway</cite>.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>looks</strong> (<em>dict</em>) – Dictionary containing results of each look at the data, indexed by the
values provided in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. Each entry of the dictionary contains:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obs</span></code><span class="classifier">array of shape (p[, q][, r])</span></dt><dd><p>Test statistic observed for all variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_values</span></code><span class="classifier">array of shape (p[, q][, r])</span></dt><dd><p>P-values for all the tests (a.k.a. variables).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H0</span></code><span class="classifier">array of shape [n_permutations]</span></dt><dd><p>Max test statistics obtained by permutations.</p>
</dd>
</dl>
</li>
<li><p><strong>ps</strong> (<em>array, shape (n_looks,)</em>) – The lowest p-value obtained at each look specied in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>. These
can be compared to <code class="docutils literal notranslate"><span class="pre">adj_alphas</span></code> to determine on which looks, if any, one
can reject the null hypothesis.</p></li>
<li><p><strong>adj_alphas</strong> (<em>array, shape (n_looks,)</em>) – The adjusted significance thresholds for each look, chosen to control the
false positive rate across multiple, sequential analyses. All p-values
should be compared to the adjusted alpha for the look at which they were
computed.</p></li>
<li><p><strong>spending</strong> (<em>array, shape (n_looks,)</em>) – The value of the alpha spending function at each look.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of and timing of looks at the data need not be planned in advance
(other than <code class="docutils literal notranslate"><span class="pre">n_max</span></code>), but it is important to include all looks that have
already occured in <code class="docutils literal notranslate"><span class="pre">look_times</span></code> each time you analyze the data to ensure that
valid adjusted significance thresholds are computed. In your final analysis,
<code class="docutils literal notranslate"><span class="pre">look_times</span></code> should contain the ordered sample sizes at all looks at the data
that occured during the study.</p>
<p>When reporting results, you should minimally include the sample sizes at each
look, the minimum p-values at each look, the adjusted significance thresholds
for each look (to which the p-values are compared), and the value of the
alpha-spending function at each look. See [3] for further recommendations.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id27"><span class="brackets">1</span></dt>
<dd><p>Gordon Lan, K. K., &amp; DeMets, D. L. (1983).
Discrete sequential boundaries for clinical trials.
Biometrika, 70(3), 659-663.</p>
</dd>
<dt class="label" id="id28"><span class="brackets">2</span></dt>
<dd><p>Lakens, D. (2014). Performing high‐powered studies efficiently with
sequential analyses. European Journal of Social Psychology, 44(7), 701-710.</p>
</dd>
<dt class="label" id="id29"><span class="brackets">3</span></dt>
<dd><p>Lakens, D., Pahlke, F., &amp; Wassmer, G. (2021).
Group Sequential Designs: A Tutorial.
<a class="reference external" href="https://doi.org/10.31234/osf.io/x4azm">https://doi.org/10.31234/osf.io/x4azm</a></p>
</dd>
<dt class="label" id="id30"><span class="brackets">4</span></dt>
<dd><p>Thomas E. Nichols and Andrew P. Holmes. Nonparametric permutation tests
for functional neuroimaging: a primer with examples.
Human Brain Mapping, 15(1):1–25, 2002. doi:10.1002/hbm.1058.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="alpha-spending-functions">
<h1>Alpha Spending Functions<a class="headerlink" href="#alpha-spending-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-niseq.spending_functions"></span><dl class="py class">
<dt class="sig sig-object py" id="niseq.spending_functions.LinearSpendingFunction">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">niseq.spending_functions.</span></span><span class="sig-name descname"><span class="pre">LinearSpendingFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.LinearSpendingFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear spending function.
This is the simplest possible spending function, which
distributes Type I error rate allowance evenly over time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.LinearSpendingFunction.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.LinearSpendingFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – An interim sample size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spending</strong> – The value of the spending function at <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.LinearSpendingFunction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.LinearSpendingFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – Desired false-positive rate after all sequential tests.</p></li>
<li><p><strong>max_n</strong> (<em>int</em>) – The sample size at which data collection will be terminated,
regardless of whether the null hypothesis has been rejected.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="niseq.spending_functions.OBrienFlemingSpendingFunction">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">niseq.spending_functions.</span></span><span class="sig-name descname"><span class="pre">OBrienFlemingSpendingFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.OBrienFlemingSpendingFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>The O’Brien Fleming spending function.
A common choice for clinical trials or other confirmatory research, this
spending function is conservative for early analyses, saving more power
for later in the study.</p>
<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.OBrienFlemingSpendingFunction.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.OBrienFlemingSpendingFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – An interim sample size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spending</strong> – The value of the spending function at <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.OBrienFlemingSpendingFunction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.OBrienFlemingSpendingFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – Desired false-positive rate after all sequential tests.</p></li>
<li><p><strong>max_n</strong> (<em>int</em>) – The sample size at which data collection will be terminated,
regardless of whether the null hypothesis has been rejected.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="niseq.spending_functions.PiecewiseSpendingFunction">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">niseq.spending_functions.</span></span><span class="sig-name descname"><span class="pre">PiecewiseSpendingFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old_spending_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">break_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.PiecewiseSpendingFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>A piecewise spending function for adjusting the maximum sample size.
A piecewise spending function to be used when adjusting your maximum sample
size. i.e., the old spending function <code class="docutils literal notranslate"><span class="pre">old_spending_func</span></code> is used up until
<code class="docutils literal notranslate"><span class="pre">break_n</span></code>, the intermediate sample size at which you decided to change the
max sample size. After that, a linear function is used that goes from
<code class="docutils literal notranslate"><span class="pre">old_spending_func(break_n)</span></code> to (<code class="docutils literal notranslate"><span class="pre">new_max_n</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>).</p>
<p>This is useful if, for instance, (1) you accidentally collect more data than
your original <code class="docutils literal notranslate"><span class="pre">max_n</span></code>, requiring you to adjust your spending function, or
(2) if a conditional power analysis encourages you to change your sample
size to acheive a desired Type II error rate. Also (3) if you can no longer
collect your original <code class="docutils literal notranslate"><span class="pre">max_n</span></code> for practical reasons.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">max_n</span></code> is adjusted multiple times, you can create piecewise spending
functions recursively.</p>
<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.PiecewiseSpendingFunction.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.PiecewiseSpendingFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – An interim sample size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spending</strong> – The value of the spending function at <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.PiecewiseSpendingFunction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old_spending_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">break_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.PiecewiseSpendingFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>old_spending_func</strong> (<em>instance of SpendingFunction</em>) – an initialized instance of a SpendingFunction subclass with
<code class="docutils literal notranslate"><span class="pre">old_spending_func.max_n</span></code> greater than <code class="docutils literal notranslate"><span class="pre">break_n</span></code>.</p></li>
<li><p><strong>break_n</strong> (<em>int</em>) – The interim sample size at which researcher decides to adjust their
maximum sample size.</p></li>
<li><p><strong>new_max_n</strong> (<em>int</em>) – The new maximum sample size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="niseq.spending_functions.PocockSpendingFunction">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">niseq.spending_functions.</span></span><span class="sig-name descname"><span class="pre">PocockSpendingFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.PocockSpendingFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>The Pocock spending function.
A very common spending function that spends your alpha budget somewhat
liberally (compared to e.g. the O’Brien-Fleming function) at the
beginning of study; consequently, you have more power early on in
exchange for a sharper penalty as you approach the maximum sample size.</p>
<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.PocockSpendingFunction.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.PocockSpendingFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – An interim sample size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spending</strong> – The value of the spending function at <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.PocockSpendingFunction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.PocockSpendingFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – Desired false-positive rate after all sequential tests.</p></li>
<li><p><strong>max_n</strong> (<em>int</em>) – The sample size at which data collection will be terminated,
regardless of whether the null hypothesis has been rejected.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="niseq.spending_functions.SpendingFunction">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">niseq.spending_functions.</span></span><span class="sig-name descname"><span class="pre">SpendingFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.SpendingFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for spending functions</p>
<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.SpendingFunction.__call__">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.SpendingFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – An interim sample size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spending</strong> – The value of the spending function at <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="niseq.spending_functions.SpendingFunction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.spending_functions.SpendingFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – Desired false-positive rate after all sequential tests.</p></li>
<li><p><strong>max_n</strong> (<em>int</em>) – The sample size at which data collection will be terminated,
regardless of whether the null hypothesis has been rejected.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-niseq.power.bootstrap">
<span id="power-analysis"></span><h1>Power Analysis<a class="headerlink" href="#module-niseq.power.bootstrap" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="niseq.power.bootstrap.bootstrap_predictive_power_1samp">
<span class="sig-prename descclassname"><span class="pre">niseq.power.bootstrap.</span></span><span class="sig-name descname"><span class="pre">bootstrap_predictive_power_1samp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_simulations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">test_func_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq.power.bootstrap.bootstrap_predictive_power_1samp" title="Permalink to this definition">¶</a></dt>
<dd><p>Predictive power analysis via Bayesian bootstrap</p>
<p>Computes the predictive power non-parametrically using the Bayesian
bootstrap. Optionally, you can condition on the current data to get
conditional power, which is useful for adaptive designs. Only valid for
one-sample (or paired-sample) tests.</p>
<p>Statistics computed from resamples using the Bayesian bootstrap, as opposed
to the frequentist boostrap, can be interpreted as draws from the posterior
distribution with an uninformative prior [1]. Thus, results here can be
conveniently interpreted as the Bayesian predictive power. As recommended by
[2] (not in English) and helpfully restated by [3] (in English), resampling
weights are drawn from Dirichlet(alpha = 4) for a better approximation.</p>
<p>This functionality is experimental. It is the best catch-all way to do a
power analysis for permutation tests I can think of, and similar resampling
approaches to estimating power have been used in the literature (e.g. by
[4]); however, it should be noted that the neuroimaging literature has not
converged upon a standardized approach to performing power analyses.
The Bayesian bootstrap approach used here incorporates uncertainty about
the effect size into the power estimate, which is handy since uncertainty
about the true effect size is considerable following a small pilot study, or
even a typical psychology/neuroimaging sample size, as pointed out by [5].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>, </em><em>p</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data from which to resample. <code class="docutils literal notranslate"><span class="pre">X</span></code> should contain the observations
for one group or paired differences. The first dimension of the array
is the number of observations; remaining dimensions comprise the size of
a single observation. See documentation for user-input <code class="docutils literal notranslate"><span class="pre">test_func</span></code> for
more details.</p></li>
<li><p><strong>test_func</strong> (<em>function</em>) – The one-sample sequential test you want to run a power analysis for.
Must accept <code class="docutils literal notranslate"><span class="pre">look_times</span></code> and <code class="docutils literal notranslate"><span class="pre">n_max</span></code> arguments and return results,
the middle two of which are the p-values for each look and the adjusted
alphas, respectively. This could be any user-facing function from
<code class="docutils literal notranslate"><span class="pre">niseq</span></code> that ends in <code class="docutils literal notranslate"><span class="pre">_1samp</span></code>.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>conditional</strong> (bool, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, performs a conditional power analysis; that is, computes
the probability of a design rejecting the null hypothesis given that the
data in <code class="docutils literal notranslate"><span class="pre">X</span></code> has already been collected and is included in the
analysis, as in an adaptive design. If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), performs a
prospective power analysis (e.g. if you’re using pilot data or data from
another study to inform sample size planning for a study that hasn’t
begun data collection).</p></li>
<li><p><strong>n_simulations</strong> (int, default: <code class="docutils literal notranslate"><span class="pre">1024</span></code>) – Number of bootstrap resamples/simulations to perform.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>**test_func_kwargs</strong> – You may input any arguments you’d like passed to <code class="docutils literal notranslate"><span class="pre">test_func</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>res</strong> – A results dictionary with keys:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'uncorr_instantaneous_power'</span></code><span class="classifier">list of float</span></dt><dd><p>The power of a fixed-sample statistical test performed at each look.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'rejection_probability'</span></code><span class="classifier">list of float</span></dt><dd><p>The probability that a sequential test rejects the null hypothesis
(for the first time) at each look time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'cumulative_power'</span></code><span class="classifier">list of float</span></dt><dd><p>The power of a sequential test to reject the null hypothesis by each
look time. <code class="docutils literal notranslate"><span class="pre">res['cumulative_power'][-1]</span></code> is the power of the full
sequential procedure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'uncorr_cumulative_power'</span></code><span class="classifier">list of float</span></dt><dd><p>Cumulative power if the rejection threshold at each look was not
corrected using alpha-spending (as it should be).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'n_expected'</span></code><span class="classifier">float</span></dt><dd><p>The expected sample size for the sequential procedure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'n_simulations'</span></code><span class="classifier">int</span></dt><dd><p>The number of bootstrap resamples used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'n_orig_data'</span></code><span class="classifier">int</span></dt><dd><p>The sample size of the original data <code class="docutils literal notranslate"><span class="pre">X</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">X.shape[0]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'conditional'</span></code><span class="classifier">bool</span></dt><dd><p>Whether the power analysis that was run was conditional (<code class="docutils literal notranslate"><span class="pre">True</span></code>)
or prospective (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'test_func'</span></code><span class="classifier">str</span></dt><dd><p>Name of the sequential test function used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'test_func_kwargs'</span></code><span class="classifier">dict</span></dt><dd><p>A record of the arguments passed to the test function, including
<code class="docutils literal notranslate"><span class="pre">look_times</span></code> and <code class="docutils literal notranslate"><span class="pre">n_max</span></code>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The significance level of the test used is specified in <code class="docutils literal notranslate"><span class="pre">test_func</span></code>, and
thus can be modified by passing an argument to <code class="docutils literal notranslate"><span class="pre">test_func</span></code> using
<code class="docutils literal notranslate"><span class="pre">**test_func_kwargs</span></code>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id31"><span class="brackets">1</span></dt>
<dd><p>Rubin, D. B. (1981). The bayesian bootstrap.
The annals of statistics, 130-134.</p>
</dd>
<dt class="label" id="id32"><span class="brackets">2</span></dt>
<dd><p>Tu, D. &amp; Zheng, Z. (1987). The Edgeworth expansion for the random
weighting method. Chinese J. Appl. Probability and Statist., 3, 340-347.</p>
</dd>
<dt class="label" id="id33"><span class="brackets">3</span></dt>
<dd><p>Shao, J., &amp; Tu, D. (2012). The jackknife and bootstrap.
Springer Science &amp; Business Media.</p>
</dd>
<dt class="label" id="id34"><span class="brackets">4</span></dt>
<dd><p>Ruzzoli, M., Torralba, M., Fernández, L. M., &amp; Soto-Faraco, S. (2019).
The relevance of alpha phase in human perception. Cortex, 120, 249-268.</p>
</dd>
<dt class="label" id="id35"><span class="brackets">5</span></dt>
<dd><p>Lakens, D., &amp; Evers, E. R. (2014). Sailing from the seas of chaos
into the corridor of stability: Practical recommendations to increase
the informational value of studies.
Perspectives on psychological science, 9(3), 278-292.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-niseq._permutation">
<span id="backend-functions"></span><h1>Backend Functions<a class="headerlink" href="#module-niseq._permutation" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="niseq._permutation.find_thresholds">
<span class="sig-prename descclassname"><span class="pre">niseq._permutation.</span></span><span class="sig-name descname"><span class="pre">find_thresholds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">look_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spending_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq._permutation.find_thresholds" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a permutation null distribution for a corresponding sequence of look
times and an alpha spending function, computes the adjusted significance
thresholds requires to control the false positive rate across all looks.</p>
<p>This isn’t meant to be accessed directly by users, but it can be used
together with <code class="docutils literal notranslate"><span class="pre">generate_permutation_dist</span></code> to create new sequential tests
if you’re confident you know what you’re doing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> (<em>array of shape</em><em> (</em><em>n_permutations</em><em>, </em><em>n_looks</em><em>)</em>) – The joint permutation null distribution of the test statistic across
look times.</p></li>
<li><p><strong>look_times</strong> (<em>list of int</em>) – Sample sizes at which statistical test is applied to the data, <em>in order</em>.
Not to exceed <code class="docutils literal notranslate"><span class="pre">max_n</span></code>.</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Sample size at which data collection is completed, regardless of whether the
null hypothesis has been rejected.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default: 0.05</em>) – Desired false positive rate after all looks at the data (i.e. at <code class="docutils literal notranslate"><span class="pre">n_max</span></code>)</p></li>
<li><p><strong>tail</strong> (<em>-1</em><em> or </em><em>0</em><em> or </em><em>1</em><em>, </em><em>default: 0</em>) – If tail is 1, the alternative hypothesis is that the
mean of the data is greater than 0 (upper tailed test).  If tail is 0,
the alternative hypothesis is that the mean of the data is different
than 0 (two tailed test).  If tail is -1, the alternative hypothesis
is that the mean of the data is less than 0 (lower tailed test).</p></li>
<li><p><strong>spending_func</strong> (<em>instance of SpendingFunction</em><em>, </em><em>default: LinearSpendingFunction</em>) – An initialized instance of one of <code class="docutils literal notranslate"><span class="pre">SpendingFunction</span></code>’s subclasses. This
defines a monotonically increasing function such that f(0) = 0 and
f(n_max) = alpha, determining how Type I error is distributed over
sequential analyses. See [2, 3] for details and provided spending functions
in <code class="docutils literal notranslate"><span class="pre">niseq.spending_functions</span></code> module.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>spending</strong> (<em>array of shape (n_looks,)</em>) – The value of the alpha spending function at each sample size
in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>.</p></li>
<li><p><strong>adj_alphas</strong> (<em>array of shape (n_looks,)</em>) – The adjusted significance threshold against which to compare p-values
at each sample size in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="niseq._permutation.generate_permutation_dist">
<span class="sig-prename descclassname"><span class="pre">niseq._permutation.</span></span><span class="sig-name descname"><span class="pre">generate_permutation_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">X</span></em>, <em class="sig-param"><span class="pre">labels</span></em>, <em class="sig-param"><span class="pre">look_times</span></em>, <em class="sig-param"><span class="pre">n_permutations=1024</span></em>, <em class="sig-param"><span class="pre">seed=None</span></em>, <em class="sig-param"><span class="pre">n_jobs=None</span></em>, <em class="sig-param"><span class="pre">statistic=&lt;function</span> <span class="pre">_get_cluster_stats_samples&gt;</span></em>, <em class="sig-param"><span class="pre">**statistic_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#niseq._permutation.generate_permutation_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the test statistic and its permutation distribution
at each look time. It isn’t meant for users to access directly for ordinary
use, though it can be used in combination with <code class="docutils literal notranslate"><span class="pre">find_thresholds</span></code> to
construct new sequential tests if you’re confident you know what you’re
doing. You’ll want to read the source code carefully to make sure your
<code class="docutils literal notranslate"><span class="pre">statistic</span></code> function is compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>[</em><em>, </em><em>p</em><em>]</em><em>[</em><em>, </em><em>q</em><em>]</em><em>[</em><em>, </em><em>r</em><em>]</em><em>)</em>) – The data to be analyzed. The first dimension of the array is the number of
observations; remaining dimensions comprise the size of a single observation.
Observations must appear in the order in which they were collected.</p></li>
<li><p><strong>labels</strong> (<em>array of shape</em><em> (</em><em>n_observations</em><em>,</em><em>) </em><em>| None</em>) – Either condition labels for each observation in <code class="docutils literal notranslate"><span class="pre">X</span></code>, a continuous
dependent variable to correlate with <code class="docutils literal notranslate"><span class="pre">X</span></code>, or None. In the latter case,
a one-sample (sign flip) permutation scheme will be used, otherwise an
independent sample (label shuffle) permutation scheme is used.</p></li>
<li><p><strong>n_permutations</strong> (<em>int</em><em>, </em><em>default: 1024</em>) – Number of permutations.</p></li>
<li><p><strong>seed</strong> (<em>None | int | instance of ~numpy.random.RandomState</em>) – A seed for the NumPy random number generator (RNG). If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
the seed will be  obtained from the operating system
(see  <code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code> for details), meaning it will most
likely produce different output every time this function or method is run.
To achieve reproducible results, pass a value here to explicitly initialize
the RNG with a defined state.</p></li>
<li><p><strong>n_jobs</strong> (<em>int | None</em>) – The number of jobs to run in parallel. If <code class="docutils literal notranslate"><span class="pre">-1</span></code>, it is set
to the number of CPU cores. Requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code> package.
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default) is a marker for ‘unset’ that will be interpreted
as <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> (sequential execution) unless the call is performed under
a <code class="xref py py-func docutils literal notranslate"><span class="pre">joblib:joblib.parallel_backend()</span></code> context manager that sets another
value for <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>.</p></li>
<li><p><strong>statistic</strong> (<em>callable</em><em>(</em><em>)</em><em>, </em><em>default: _get_cluster_stats_samples</em>) – The test statistic to compute on the data, e.g. a cluster statistic or
a max-t statistic. The last value <code class="docutils literal notranslate"><span class="pre">statistic</span></code> returns must be the
omnibus test statistic (e.g. the max-t or the cluster size), though you
can return whatever other stuff you want which will be passed through
the <code class="docutils literal notranslate"><span class="pre">obs</span></code> dictionary.</p></li>
<li><p><strong>**statistic_kwargs</strong> – You may pass arbitrary arguments to the <code class="docutils literal notranslate"><span class="pre">statistic</span></code> function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>obs</strong> (<em>dict</em>) – The output of <cite>statistic</cite> indexed by look time in <code class="docutils literal notranslate"><span class="pre">look_times</span></code>.</p></li>
<li><p><strong>H0</strong> (<em>array of shape (n_permutations, n_looks)</em>) – The joint permutation null distribution of the test statistic across
look times.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="toctree-wrapper compound">
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">niseq</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, John Veillette.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>